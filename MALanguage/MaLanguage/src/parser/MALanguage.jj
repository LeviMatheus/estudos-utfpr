/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. MALanguage.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */

/*
	TODO: implementar fun\u00ef\u00bf\u00bd\u00ef\u00bf\u00bdes do sistema e declara\u00ef\u00bf\u00bd\u00ef\u00bf\u00bdo de fun\u00ef\u00bf\u00bd\u00ef\u00bf\u00bdes do usu\u00ef\u00bf\u00bdrio, la\u00ef\u00bf\u00bdo de repeti\u00ef\u00bf\u00bd\u00ef\u00bf\u00bdo, documenta\u00ef\u00bf\u00bd\u00ef\u00bf\u00bdo (programas v\u00ef\u00bf\u00bdlidas e inv\u00ef\u00bf\u00bdlidos)
	IDEIAS: BYAKUGAN = OLHO QUE TUDO VE = IF
			SHARINGAN = OLHO DA PERCEPCAO = TRYCATCH
			
*/

options
{
  static = true;
}

PARSER_BEGIN(MALanguage)
package parser;
import recovery.*;

public class MALanguage/*@bgen(jjtree)*/implements MALanguageTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTMALanguageState jjtree = new JJTMALanguageState();

/*@egen*/
	public static void main(String args []) throws ParseException
 	{
		MALanguage parser = new MALanguage(System.in);
		while (true)
		{
		  System.out.println("ikimasho: \n");
		  try
		  {
		  	SimpleNode n = parser.principal();
		  	n.dump(" ", window);
		  }
		  catch (Exception e)
		  {
		    System.out.println("chotto matte.");
		    System.out.println(e.getMessage());
		    MALanguage.ReInit(System.in);
		  }
		  catch (Error e)
		  {
		    System.out.println("yamerooo.");
		    System.out.println(e.getMessage());
		    break;
		  }
		}
	}
	static public String im(int x)
  	{
	    int k;
		String s;
	    s = tokenImage[x];
	    k = s.lastIndexOf("\"");
	    try {
	      s = s.substring(1,k);
	    }
	   catch (StringIndexOutOfBoundsException e)
		   {}
	   return s;
  	}
	
  	static Token lastError = null;
  	static boolean eof;    // vari\u00e1vel que indica se EOF foi alcan\u00e7ado
	
  	// o m\u00e9todo abaixo consome tokens at\u00e9 alcan\u00e7ar um que perten\u00e7a ao conjunto
  	// de sincroniza\u00e7\u00e3o
  	static void consumeUntil(RecoverySet g,
	                 ParseException e,
	                 String met) throws ParseEOFException,
	                                    ParseException
  {
	Token tok;
	System.out.println();
	System.out.println("*** " + met + " ***");
	System.out.println("     Conjunto de sincroniza\u00e7\u00e3o: " + g);
		
	if (g == null) throw e; // se o conjunto \u00e9 null, propaga a exce\u00e7\u00e3o
	
	tok = getToken(1); // pega token corrente
	while ( ! eof )	{ // se n\u00e3o chegou ao fim do arquivo
	  if ( g.contains(tok.kind)) {//achou um token no conjunto
	    System.out.println("     Encontrado token de sincroniza\u00e7\u00e3o: " + 
	                       im(tok.kind));
	    break;
	  }
	  System.out.println("     Ignorando o token: " + im(tok.kind));
	  getNextToken();     // pega pr\u00f3ximo token       
      tok = getToken(1);
	  if (tok.kind == EOF && ! g.contains(EOF) ) // fim da entrada?   
	      eof = true;
	}
    if ( tok != lastError)  {
	  System.out.println(e.getMessage());
	  lastError = tok;
	   
	}
	if ( eof )
	  throw new ParseEOFException("Encontrei EOF onde n\u00e3o deveria.");
  	}
}

PARSER_END(MALanguage)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /* OPERATORS */
{
  < INICIOPROGRAMA    : "omaewamoushindeiru" | "zawarudo" | "sasageyo">
| < FIMPROGRAMA        : "naniii" | "roadrollerda">
| < INICIOBLOCO     : "smaaash" >
| < FIMBLOCO        : "ussmaaash" | "californiasmaaash" | "carolinasmaaash" | "detroitsmaaash" | "doubledetroitsmaaash"
| "missourismaaash" | "nebraskasmaaash" | "newhampshiresmaaash" | "oklahomasmaaash" | "texassmaaash" >
| < REAL            : "yandere" >
| < BOOLEAN 		: "kuudere" >
| < INTEIRO         : "deredere" >
| < LETRA            : "tsuntsun" >
| < STRING           : "tsundere" >
| < FIMINSTRUCAO     : ("desu") >
| < DIGITO            : ["0"-"9"] >
| < CARACTERE        : (["A"-"Z"] | ["a"-"z"]) >
| < ATRIBUICAO        : "=" >
| < SEPARADOR        : "," >
| < IDENTIFICADOR    : "tuturu_"(<CARACTERE>|<DIGITO>)+ >
| < IF				: "moemoe" >
| < ELSE			: "kyun" >
| < LPAR			: "(" >
| < RPAR			: ")" >
| < DECIMAL 		: "." >
| < OPERADOR_LOGICO		: "<" | ">" | "==" | "&" | "ou">
| < OPERADOR_ARITMETICO : "+" | "-" | "*" | "/" >
| < FOR : "steins" > 
| < FUNCTION : "bankai_"(<CARACTERE>|<DIGITO>)+ >
| < WHILE : "ayaya" >
| < ISTRING : "'" >
| < INTERRUPCAO : "yamero" >
| < TRUE 		: "redonda" >
| < FALSE		: "plana" >
}

void principal() :
{/*@bgen(jjtree) principal */
  SimpleNode jjtn000 = new SimpleNode(JJTPRINCIPAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) principal */
        try {
/*@egen*/
	< INICIOPROGRAMA >
  	< INICIOBLOCO >
  	(comandos())*
  	< FIMBLOCO >
  	< FIMPROGRAMA >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ 
}

void comandos():
{/*@bgen(jjtree) comandos */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMANDOS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) comandos */
        try {
/*@egen*/
  //comandos
	condicional() | declaracaoVariavel() | repeticao() | function()  | stmt()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void function():
{/*@bgen(jjtree) function */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) function */
        try {
/*@egen*/
	< FUNCTION > < LPAR > ( (< IDENTIFICADOR > /*| dado()*/) (< SEPARADOR > (< IDENTIFICADOR > /*| dado()*/))* )* < RPAR > < FIMINSTRUCAO >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void stmt()://statement
{/*@bgen(jjtree) stmt */
  SimpleNode jjtn000 = new SimpleNode(JJTSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) stmt */
        try {
/*@egen*/
	expressao() < FIMINSTRUCAO >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void condicional():
{/*@bgen(jjtree) condicional */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDICIONAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) condicional */
        try {
/*@egen*/
	< IF > < LPAR > expressao() < RPAR >
	< INICIOBLOCO >
		//LOOKAHEAD(1) 
		(declaracaoVariavel() | repeticao() /*| stmt() */ )*
	< FIMBLOCO >
	(		< ELSE >
		< INICIOBLOCO >
			//LOOKAHEAD(1)
			(declaracaoVariavel() | repeticao() /*| stmt() */)*
		< FIMBLOCO >
	)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void repeticao():
{/*@bgen(jjtree) repeticao */
  SimpleNode jjtn000 = new SimpleNode(JJTREPETICAO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) repeticao */
                try {
/*@egen*/
  	/* EXEMPLO
  	steins(a<0 gate a++) {
  	  comandos
    }
    */
		(		< FOR > < LPAR > (numero()|< IDENTIFICADOR >) < RPAR >
		(		 	< INICIOBLOCO >
		 		(		 		  comandos()
		 		)*
			< FIMBLOCO >
		)?
	)|//ou
	(
		< WHILE > < LPAR > (expressao())? <RPAR > /* se vazio == true */
	    <INICIOBLOCO >
	    	(
	    	  comandos()	    	)*
		< FIMBLOCO >	)/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
                }
/*@egen*/
}

void expressao():
{/*@bgen(jjtree) expressao */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSAO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) expressao */
        try {
/*@egen*/ 
	(  	  (numero() | < IDENTIFICADOR >) (< OPERADOR_LOGICO > | < OPERADOR_ARITMETICO >) (numero() | < IDENTIFICADOR >))/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}

void declaracaoVariavel():
{/*@bgen(jjtree) declaracaoVariavel */
  SimpleNode jjtn000 = new SimpleNode(JJTDECLARACAOVARIAVEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) declaracaoVariavel */
        try {
/*@egen*/
  	/* atribuicao basica, tipo, int a = 2;  */
	tipoDado() <IDENTIFICADOR > (< ATRIBUICAO > ( < CARACTERE >| numero() ) )? (< SEPARADOR > < IDENTIFICADOR > (< ATRIBUICAO > ( < CARACTERE >|numero()) )?)* <FIMINSTRUCAO >/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void string(): 
{/*@bgen(jjtree) string */
  SimpleNode jjtn000 = new SimpleNode(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) string */
        try {
/*@egen*/
	(< ISTRING >)(< CARACTERE > | < DIGITO >)*(< ISTRING >)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void numero():
{/*@bgen(jjtree) numero */
  SimpleNode jjtn000 = new SimpleNode(JJTNUMERO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) numero */
        try {
/*@egen*/
	(< DIGITO >)+/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void bool():
{/*@bgen(jjtree) bool */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) bool */
        try {
/*@egen*/
	< TRUE > | < FALSE >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*void dado():
{RecoverySet g = First.dado;}
{
  	try {
		(numero() | string() | bool())
	} catch (ParseException e) {
		consumeUntil(g, e, "Principal");
	}
	
	{
		return jjtThis;
	}
}*/

void tipoDado():
{/*@bgen(jjtree) tipoDado */
  SimpleNode jjtn000 = new SimpleNode(JJTTIPODADO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) tipoDado */
        try {
/*@egen*/
	< REAL >|< INTEIRO >|< LETRA >|< STRING >|< BOOLEAN >/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
} 